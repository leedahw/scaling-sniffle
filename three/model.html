<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title>ThreeJS Model</title>

        <script src="js/THREEx.WindowResize.js"></script>
        <script src="js/THREEx.FullScreen.js"></script>


        <script type="module">

        // Find the latest version by visiting https://unpkg.com/three. The URL will
        // redirect to the newest stable release.
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import {OrbitControls} from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import {GLTFLoader} from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
        import { Refractor } from 'https://unpkg.com/three/examples/jsm/objects/Refractor.js';
        import { WaterRefractionShader } from 'https://unpkg.com/three/examples/jsm/shaders/WaterRefractionShader.js';
        

        //GLOBAL VARIABLE
        let scene, camera, clock, renderer, refractor, listener;

        //SCENE
        scene = new THREE.Scene();

        // clock
        clock = new THREE.Clock();

        // CAMERA
        const viewAngle = 45;
        const windowW = window.innerWidth;
        const windowH = window.innerHeight;
        const aspectRatio = windowW/windowH;
        const near = 10;
        const far = 1000;

        camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, near, far);
        // camera.position.z = 30; // back out of screen from origin (0,0,0)
        //camera.position.set(0,100,0); // x,y,z
        camera.position.set(100, 100, -80);

        
        // RENDERER
        renderer = new THREE.WebGLRenderer({antialias:true, physicallyCorrectLights: true});
        renderer.setSize(windowW, windowH);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        
        //LISTENER & AUDIO
        listener = new THREE.AudioListener();
        camera.add( listener );

        // create a global audio source
        const sound = new THREE.Audio( listener );
        // load a sound and set it as the Audio object's buffer
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load( 'sounds/water.ogg', function( buffer ) {
            sound.setBuffer( buffer );
            sound.setLoop( true );
            sound.setVolume( 0.5 );
            sound.play();
        });

        const sound2 = new THREE.Audio( listener );
        const audioLoader2 = new THREE.AudioLoader();


        // COLORED background - replace HEXCODDE with any hex color
        renderer.setClearColor( 0x101d30 ); 

        //SHOW AXES FOR REF. for POSITIONING
        const axesHelper = new THREE.AxesHelper( 200 );
        scene.add( axesHelper );

        // EVENTS
        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({charCode : "m".charCodeAt()});

        //WATER MESH
        const refractorGeometry = new THREE.CircleGeometry( 50 , 50 );

        refractor = new Refractor (refractorGeometry, {
            color:0x9ca9ba,
            textureWidth: 1800,
            textureHeight:1800,
            shader: WaterRefractionShader
        });
        
        refractor.position.set(0,5,0);
        refractor.rotation.x = -(Math.PI/2);
        scene.add(refractor);

        const dudvMap = new THREE.TextureLoader().load( 'images/waterdudv.jpg', function() {
            animate();
        } );

        dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;
        refractor.material.uniforms["tDudv"].value = dudvMap;

        
        //DIRT GROUND texture & Material
        let groundTexture = new THREE.TextureLoader().load('images/pond.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;

        groundTexture.repeat.set(0.5,0.5);
        groundTexture.anistropy= 46;
        groundTexture.encoding = THREE.sRGBENcoding;

		var groundMaterial = new THREE.MeshStandardMaterial( { map: groundTexture } );

		var mesh = new THREE.Mesh( new THREE.CylinderGeometry( 50, 50, 10, 100 ), groundMaterial );
		mesh.position.y = -5;
		//mesh.rotation.x = - Math.PI / 2;
		mesh.receiveShadow = true;
		scene.add( mesh );


        // LAMP MODEL
        const lamp = new GLTFLoader();
        lamp.load("lamp/scene.gltf", gltf=>{
            gltf.scene.scale.multiplyScalar(100);
            gltf.scene.position.x = 10;
            gltf.scene.position.z = 8;
            gltf.scene.position.y = 15;
            gltf.scene.castShadow = true;

        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });



        //ROCK MODEL
        const rock = new GLTFLoader();
        rock.load("rock/scene.gltf", gltf=>{
            // adjust scalar factor to match your scene scale
            gltf.scene.scale.multiplyScalar(1 / 2);
            //gltf.scene.rotation.z = 180;
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });

        //FROG MODEL
        const frog = new GLTFLoader();
        frog.load("frog/scene.gltf", gltf=>{
            // adjust scalar factor to match your scene scale
            gltf.scene.position.y = 19;
            gltf.scene.position.x = 4;
            gltf.scene.position.z = -3;
            gltf.scene.rotation.y = 90;
            gltf.scene.scale.multiplyScalar(3 / 4);
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });
        frog.castShadow=true;
        

        //LIGHTS
        const light2 = new THREE.PointLight( 0xffffff,.5,50,2 );
        light2.position.set(100,100,100);
        scene.add(light2);

        // Load Light
        const ambientLight = new THREE.AmbientLight( 0x404040 );
        scene.add( ambientLight );


        //LIGHT COMING FROM LAMP
        const spotLight = new THREE.PointLight( 0xffee88, 1, 80, 2 );
        spotLight.position.set(4, 45, 4);
        spotLight.castShadow = true;
        //spotLight.target.position.set(4,20,-3);
        //scene.add( spotLight.target );
        scene.add(spotLight);
        
        //const spotLightHelper = new THREE.SpotLightHelper( spotLight );
        //scene.add( spotLightHelper );

        // CONTROLS
        const controls = new OrbitControls(camera, renderer.domElement);


        //ADD RAYCASTER AND MOUSE ELEMENT AS 2D VECTOR (X,Y)point.
        var raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        //2nd event listener is for mobile touch screens
        //document.addEventListener ('touchstart',onDocumentTouchStart, false);

        function onDocumentMouseDown (event){
            //cancel default method
            event.preventDefault();
            //set x,y vales based on raycasted values of mouse
            mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

            //console.log(mouse);
            raycaster.setFromCamera(mouse,camera);
            const intersects = raycaster.intersectObjects( scene.children, true );

            if (intersects.length > 0) {
                console.log('Intersection: ', intersects[0]);
                    //toggle light on and off
                    if (spotLight.visible === true) {
                        spotLight.visible=false;
                    }else {
                        spotLight.visible=true;
                    }

                    //play ribbit.ogg
                    audioLoader2.load( 'sounds/ribbit.ogg', function( buffer ) {
                        sound2.setBuffer( buffer );
                        sound2.setLoop( false );
                        sound2.setVolume( 0.5 );
                        sound2.play(false);
                        sound2.play();
                    });
                    
                    
            }else {
                console.log('failed');
            }

        }

        //ANIMATE 
        function animate () {
            requestAnimationFrame(animate);
            render();
        }


        function render() {
            refractor.material.uniforms[ "time" ].value += clock.getDelta();

            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        render();

        renderer.domElement.addEventListener( 'click', onDocumentMouseDown, false );

        </script>
		<meta name="viewport" content="width=device-width, user-scalable=no" />
		<style>
		body {margin:0px;}
		canvas {width:100%; height:100%;}
		</style>

    </head>
    <body>
        <button style="position:absolute;">PLAY</button>
    </body>
</html>
